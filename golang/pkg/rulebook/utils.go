//
// Utility Functions
//
// Auto-generated from rulebook
// Model: FractalsAndPowerLaws_CMCC
// Generated: 2025-12-11 21:37:34 UTC
//
// DO NOT EDIT THIS FILE MANUALLY
// Regenerate by running: python rulebook-to-golang.py
//
package rulebook

import "math"


// BuildSystemsDict builds a map of systems keyed by SystemID
func BuildSystemsDict(systems []*System) map[string]*System {
    dict := make(map[string]*System)
    for _, s := range systems {
        dict[s.SystemID] = s
    }
    return dict
}


// CalculateAllScales calculates all derived fields for all scales
func CalculateAllScales(scales []*Scale, systemsDict map[string]*System) {
    for _, item := range scales {
        item.CalculateBasescale(systemsDict)
        item.CalculateScalefactor(systemsDict)
        item.CalculateScalefactorpower()
        item.CalculateScale()
        item.CalculateLogscale()
        item.CalculateLogmeasure()
    }
}

// CalculateAllSystemStatss calculates all derived fields for all system_stats
func CalculateAllSystemStatss(system_stats []*SystemStats, systemsDict map[string]*System, scales []*Scale) {
    for _, item := range system_stats {
        item.CalculateSystemdisplayname(systemsDict)
        item.CalculateTheoreticalloglogslope(systemsDict)
        item.CalculatePointcount(scales)
        item.CalculateMinlogscale(scales)
        item.CalculateMaxlogscale(scales)
        item.CalculateMinlogmeasure(scales)
        item.CalculateMaxlogmeasure(scales)
        item.CalculateDeltalogmeasure()
        item.CalculateDeltalogscale()
        item.CalculateEmpiricalloglogslope()
        item.CalculateSlopeerror()
    }
}


// ValidateSystem checks if empirical slope matches theoretical slope
func ValidateSystem(stats *SystemStats, tolerance float64) bool {
    if stats.cachedSlopeError == nil {
        return false
    }
    error := *stats.cachedSlopeError
    return math.Abs(error) < tolerance
}
