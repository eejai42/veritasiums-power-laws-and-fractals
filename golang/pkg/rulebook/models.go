//
// Data Models
//
// Auto-generated from rulebook
// Model: FractalsAndPowerLaws_CMCC
// Generated: 2025-12-11 21:37:34 UTC
//
// DO NOT EDIT THIS FILE MANUALLY
// Regenerate by running: python rulebook-to-golang.py
//

package rulebook



import (

    "math"

)



// System represents Each row is a fractal or power-law system described in a common schema.
type System struct {
    Systemid string `json:"system_id"`
    Displayname string `json:"display_name"`
    Class string `json:"class"`
    Basescale float64 `json:"base_scale"`
    Scalefactor float64 `json:"scale_factor"`
    Measurename string `json:"measure_name"`
    Fractaldimension float64 `json:"fractal_dimension"`
    Theoreticalloglogslope float64 `json:"theoretical_log_log_slope"`
}


// Scale represents Generic logâ€“log points for each system at multiple iterations / scales.
type Scale struct {
    Scaleid string `json:"scale_id"`
    System string `json:"system"`
    Iteration int `json:"iteration"`
    Measure float64 `json:"measure"`
    cachedBasescale *float64
    cachedScalefactor *float64
    cachedScalefactorpower *float64
    cachedScale *float64
    cachedLogscale *float64
    cachedLogmeasure *float64
}

// CalculateBasescale calculates Base scale looked up from parent system.
// Formula: =INDEX(systems!{{BaseScale}}, MATCH(scales!{{System}}, systems!{{SystemID}}, 0))
func (s *Scale) CalculateBasescale(systemsDict map[string]*System) float64 {
    if s.cachedBasescale == nil {
        result := systemsMap[s.System].Basescale
        s.cachedBasescale = &result
    }
    return *s.cachedBasescale
}

// CalculateScalefactor calculates Scale factor looked up from parent system.
// Formula: =INDEX(systems!{{ScaleFactor}}, MATCH(scales!{{System}}, systems!{{SystemID}}, 0))
func (s *Scale) CalculateScalefactor(systemsDict map[string]*System) float64 {
    if s.cachedScalefactor == nil {
        result := systemsMap[s.System].Scalefactor
        s.cachedScalefactor = &result
    }
    return *s.cachedScalefactor
}

// CalculateScalefactorpower calculates ScaleFactor raised to the Iteration power.
// Formula: =POWER({{ScaleFactor}}, {{Iteration}})
func (s *Scale) CalculateScalefactorpower() float64 {
    if s.cachedScalefactorpower == nil {
        result := math.Pow(*s.cachedScalefactor, s.Iteration)
        s.cachedScalefactorpower = &result
    }
    return *s.cachedScalefactorpower
}

// CalculateScale calculates X-axis variable: BaseScale multiplied by ScaleFactorPower.
// Formula: ={{BaseScale}} * {{ScaleFactorPower}}
func (s *Scale) CalculateScale() float64 {
    if s.cachedScale == nil {
        result := *s.cachedBasescale * *s.cachedScalefactorpower
        s.cachedScale = &result
    }
    return *s.cachedScale
}

// CalculateLogscale calculates log10 of Scale.
// Formula: =LOG10({{Scale}})
func (s *Scale) CalculateLogscale() float64 {
    if s.cachedLogscale == nil {
        result := math.Log10(*s.cachedScale)
        s.cachedLogscale = &result
    }
    return *s.cachedLogscale
}

// CalculateLogmeasure calculates log10 of Measure.
// Formula: =LOG10({{Measure}})
func (s *Scale) CalculateLogmeasure() float64 {
    if s.cachedLogmeasure == nil {
        result := math.Log10(s.Measure)
        s.cachedLogmeasure = &result
    }
    return *s.cachedLogmeasure
}


// SystemStats represents Statistical analysis of each system's log-log behavior, with rollups from scales and lookups to systems.
type SystemStats struct {
    Systemstatsid string `json:"system_stats_id"`
    System string `json:"system"`
    Analysisname string `json:"analysis_name"`
    Status string `json:"status"`
    cachedSystemdisplayname *string
    cachedTheoreticalloglogslope *float64
    cachedPointcount *int
    cachedMinlogscale *float64
    cachedMaxlogscale *float64
    cachedMinlogmeasure *float64
    cachedMaxlogmeasure *float64
    cachedDeltalogmeasure *float64
    cachedDeltalogscale *float64
    cachedEmpiricalloglogslope *float64
    cachedSlopeerror *float64
}

// CalculateSystemdisplayname calculates Display name looked up from parent system.
// Formula: =INDEX(systems!{{DisplayName}}, MATCH(system_stats!{{System}}, systems!{{SystemID}}, 0))
func (s *SystemStats) CalculateSystemdisplayname(systemsDict map[string]*System) string {
    if s.cachedSystemdisplayname == nil {
        result := systemsMap[s.System].Displayname
        s.cachedSystemdisplayname = &result
    }
    return *s.cachedSystemdisplayname
}

// CalculateTheoreticalloglogslope calculates Theoretical slope looked up from parent system.
// Formula: =INDEX(systems!{{TheoreticalLogLogSlope}}, MATCH(system_stats!{{System}}, systems!{{SystemID}}, 0))
func (s *SystemStats) CalculateTheoreticalloglogslope(systemsDict map[string]*System) float64 {
    if s.cachedTheoreticalloglogslope == nil {
        result := systemsMap[s.System].Theoreticalloglogslope
        s.cachedTheoreticalloglogslope = &result
    }
    return *s.cachedTheoreticalloglogslope
}

// CalculatePointcount calculates Rollup: Count of scale measurements for this system.
// Formula: =COUNTIF(scales!{{System}}, {{System}})
func (s *SystemStats) CalculatePointcount(scales []*Scale) int {
    if s.cachedPointcount == nil {
        result := count := 0
for _, s := range scales {
    if s.System == ss.System {
        count++
    }
}
return count
        s.cachedPointcount = &result
    }
    return *s.cachedPointcount
}

// CalculateMinlogscale calculates Rollup: Minimum log10(Scale) across child scales.
// Formula: =MINIFS(scales!{{LogScale}}, scales!{{System}}, {{System}})
func (s *SystemStats) CalculateMinlogscale(scales []*Scale) float64 {
    if s.cachedMinlogscale == nil {
        result := result := math.MaxFloat64
for _, s := range scales {
    if s.System == ss.System {
        val := s.CalculateLogscale(scalesMap)
        if val < result {
            result = val
        }
    }
}
return result
        s.cachedMinlogscale = &result
    }
    return *s.cachedMinlogscale
}

// CalculateMaxlogscale calculates Rollup: Maximum log10(Scale) across child scales.
// Formula: =MAXIFS(scales!{{LogScale}}, scales!{{System}}, {{System}})
func (s *SystemStats) CalculateMaxlogscale(scales []*Scale) float64 {
    if s.cachedMaxlogscale == nil {
        result := result := -math.MaxFloat64
for _, s := range scales {
    if s.System == ss.System {
        val := s.CalculateLogscale(scalesMap)
        if val > result {
            result = val
        }
    }
}
return result
        s.cachedMaxlogscale = &result
    }
    return *s.cachedMaxlogscale
}

// CalculateMinlogmeasure calculates Rollup: Minimum log10(Measure) across child scales.
// Formula: =MINIFS(scales!{{LogMeasure}}, scales!{{System}}, {{System}})
func (s *SystemStats) CalculateMinlogmeasure(scales []*Scale) float64 {
    if s.cachedMinlogmeasure == nil {
        result := result := math.MaxFloat64
for _, s := range scales {
    if s.System == ss.System {
        val := s.CalculateLogmeasure(scalesMap)
        if val < result {
            result = val
        }
    }
}
return result
        s.cachedMinlogmeasure = &result
    }
    return *s.cachedMinlogmeasure
}

// CalculateMaxlogmeasure calculates Rollup: Maximum log10(Measure) across child scales.
// Formula: =MAXIFS(scales!{{LogMeasure}}, scales!{{System}}, {{System}})
func (s *SystemStats) CalculateMaxlogmeasure(scales []*Scale) float64 {
    if s.cachedMaxlogmeasure == nil {
        result := result := -math.MaxFloat64
for _, s := range scales {
    if s.System == ss.System {
        val := s.CalculateLogmeasure(scalesMap)
        if val > result {
            result = val
        }
    }
}
return result
        s.cachedMaxlogmeasure = &result
    }
    return *s.cachedMaxlogmeasure
}

// CalculateDeltalogmeasure calculates Calculated: Difference between min and max log measure (numerator for slope).
// Formula: ={{MinLogMeasure}} - {{MaxLogMeasure}}
func (s *SystemStats) CalculateDeltalogmeasure() float64 {
    if s.cachedDeltalogmeasure == nil {
        result := *s.cachedMinlogmeasure - *s.cachedMaxlogmeasure
        s.cachedDeltalogmeasure = &result
    }
    return *s.cachedDeltalogmeasure
}

// CalculateDeltalogscale calculates Calculated: Difference between max and min log scale (denominator for slope).
// Formula: ={{MaxLogScale}} - {{MinLogScale}}
func (s *SystemStats) CalculateDeltalogscale() float64 {
    if s.cachedDeltalogscale == nil {
        result := *s.cachedMaxlogscale - *s.cachedMinlogscale
        s.cachedDeltalogscale = &result
    }
    return *s.cachedDeltalogscale
}

// CalculateEmpiricalloglogslope calculates Calculated: Slope of log-log line from empirical data.
// Formula: ={{DeltaLogMeasure}} / {{DeltaLogScale}}
func (s *SystemStats) CalculateEmpiricalloglogslope() float64 {
    if s.cachedEmpiricalloglogslope == nil {
        result := *s.cachedDeltalogmeasure / *s.cachedDeltalogscale
        s.cachedEmpiricalloglogslope = &result
    }
    return *s.cachedEmpiricalloglogslope
}

// CalculateSlopeerror calculates Calculated: Difference between empirical and theoretical slopes.
// Formula: ={{EmpiricalLogLogSlope}} - {{TheoreticalLogLogSlope}}
func (s *SystemStats) CalculateSlopeerror() float64 {
    if s.cachedSlopeerror == nil {
        result := *s.cachedEmpiricalloglogslope - *s.cachedTheoreticalloglogslope
        s.cachedSlopeerror = &result
    }
    return *s.cachedSlopeerror
}
