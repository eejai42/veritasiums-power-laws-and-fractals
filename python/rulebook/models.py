"""
Data Models

Auto-generated from rulebook
Model: FractalsAndPowerLaws_CMCC
Generated: 2025-12-11 21:36:10 UTC

DO NOT EDIT THIS FILE MANUALLY
Regenerate by running: python rulebook-to-python.py
"""

from dataclasses import dataclass, field
from typing import Optional, Dict, List
import math


@dataclass
class System:
    """
    Each row is a fractal or power-law system described in a common schema.
    """
    system_id: str
    display_name: str
    class_: str
    base_scale: Optional[float]
    scale_factor: Optional[float]
    measure_name: str
    fractal_dimension: Optional[float]
    theoretical_log_log_slope: Optional[float]


@dataclass
class Scale:
    """
    Generic logâ€“log points for each system at multiple iterations / scales.
    """
    scale_id: str
    system: str
    iteration: Optional[int]
    measure: Optional[float]
    _base_scale: Optional[Optional[float]] = field(default=None, repr=False)
    _scale_factor: Optional[Optional[float]] = field(default=None, repr=False)
    _scale_factor_power: Optional[Optional[float]] = field(default=None, repr=False)
    _scale: Optional[Optional[float]] = field(default=None, repr=False)
    _log_scale: Optional[Optional[float]] = field(default=None, repr=False)
    _log_measure: Optional[Optional[float]] = field(default=None, repr=False)

    def calculate_base_scale(self, systems_dict: Dict[str, System]) -> Optional[float]:
        """
        Base scale looked up from parent system.
        Formula: =INDEX(systems!{{BaseScale}}, MATCH(scales!{{System}}, systems!{{SystemID}}, 0))
        """
        if self._base_scale is None:
            result = systems_dict.get(self.system).base_scale if systems_dict.get(self.system) else None
            self._base_scale = result if result is not None else 0.0
        return self._base_scale

    def calculate_scale_factor(self, systems_dict: Dict[str, System]) -> Optional[float]:
        """
        Scale factor looked up from parent system.
        Formula: =INDEX(systems!{{ScaleFactor}}, MATCH(scales!{{System}}, systems!{{SystemID}}, 0))
        """
        if self._scale_factor is None:
            result = systems_dict.get(self.system).scale_factor if systems_dict.get(self.system) else None
            self._scale_factor = result if result is not None else 0.0
        return self._scale_factor

    def calculate_scale_factor_power(self) -> Optional[float]:
        """
        ScaleFactor raised to the Iteration power.
        Formula: =POWER({{ScaleFactor}}, {{Iteration}})
        """
        if self._scale_factor_power is None:
            self._scale_factor_power = math.pow(self._scale_factor, self.iteration)
        return self._scale_factor_power

    def calculate_scale(self) -> Optional[float]:
        """
        X-axis variable: BaseScale multiplied by ScaleFactorPower.
        Formula: ={{BaseScale}} * {{ScaleFactorPower}}
        """
        if self._scale is None:
            self._scale = self._base_scale * self._scale_factor_power
        return self._scale

    def calculate_log_scale(self) -> Optional[float]:
        """
        log10 of Scale.
        Formula: =LOG10({{Scale}})
        """
        if self._log_scale is None:
            self._log_scale = math.log10(self._scale)
        return self._log_scale

    def calculate_log_measure(self) -> Optional[float]:
        """
        log10 of Measure.
        Formula: =LOG10({{Measure}})
        """
        if self._log_measure is None:
            self._log_measure = math.log10(self.measure)
        return self._log_measure


@dataclass
class SystemStats:
    """
    Statistical analysis of each system's log-log behavior, with rollups from scales and lookups to systems.
    """
    system_stats_id: str
    system: str
    analysis_name: str
    status: str
    _system_display_name: Optional[str] = field(default=None, repr=False)
    _theoretical_log_log_slope: Optional[Optional[float]] = field(default=None, repr=False)
    _point_count: Optional[Optional[int]] = field(default=None, repr=False)
    _min_log_scale: Optional[Optional[float]] = field(default=None, repr=False)
    _max_log_scale: Optional[Optional[float]] = field(default=None, repr=False)
    _min_log_measure: Optional[Optional[float]] = field(default=None, repr=False)
    _max_log_measure: Optional[Optional[float]] = field(default=None, repr=False)
    _delta_log_measure: Optional[Optional[float]] = field(default=None, repr=False)
    _delta_log_scale: Optional[Optional[float]] = field(default=None, repr=False)
    _empirical_log_log_slope: Optional[Optional[float]] = field(default=None, repr=False)
    _slope_error: Optional[Optional[float]] = field(default=None, repr=False)

    def calculate_system_display_name(self, systems_dict: Dict[str, System]) -> str:
        """
        Display name looked up from parent system.
        Formula: =INDEX(systems!{{DisplayName}}, MATCH(system_stats!{{System}}, systems!{{SystemID}}, 0))
        """
        if self._system_display_name is None:
            result = systems_dict.get(self.system).display_name if systems_dict.get(self.system) else None
            self._system_display_name = result if result is not None else 0.0
        return self._system_display_name

    def calculate_theoretical_log_log_slope(self, systems_dict: Dict[str, System]) -> Optional[float]:
        """
        Theoretical slope looked up from parent system.
        Formula: =INDEX(systems!{{TheoreticalLogLogSlope}}, MATCH(system_stats!{{System}}, systems!{{SystemID}}, 0))
        """
        if self._theoretical_log_log_slope is None:
            result = systems_dict.get(self.system).theoretical_log_log_slope if systems_dict.get(self.system) else None
            self._theoretical_log_log_slope = result if result is not None else 0.0
        return self._theoretical_log_log_slope

    def calculate_point_count(self, scales: List[Scale]) -> Optional[int]:
        """
        Rollup: Count of scale measurements for this system.
        Formula: =COUNTIF(scales!{{System}}, {{System}})
        """
        if self._point_count is None:
            self._point_count = sum(1 for s in scales if s.system == self.system)
        return self._point_count

    def calculate_min_log_scale(self, scales: List[Scale]) -> Optional[float]:
        """
        Rollup: Minimum log10(Scale) across child scales.
        Formula: =MINIFS(scales!{{LogScale}}, scales!{{System}}, {{System}})
        """
        if self._min_log_scale is None:
            self._min_log_scale = min((s._log_scale for s in scales if s.system == self.system), default=0)
        return self._min_log_scale

    def calculate_max_log_scale(self, scales: List[Scale]) -> Optional[float]:
        """
        Rollup: Maximum log10(Scale) across child scales.
        Formula: =MAXIFS(scales!{{LogScale}}, scales!{{System}}, {{System}})
        """
        if self._max_log_scale is None:
            self._max_log_scale = max((s._log_scale for s in scales if s.system == self.system), default=0)
        return self._max_log_scale

    def calculate_min_log_measure(self, scales: List[Scale]) -> Optional[float]:
        """
        Rollup: Minimum log10(Measure) across child scales.
        Formula: =MINIFS(scales!{{LogMeasure}}, scales!{{System}}, {{System}})
        """
        if self._min_log_measure is None:
            self._min_log_measure = min((s._log_measure for s in scales if s.system == self.system), default=0)
        return self._min_log_measure

    def calculate_max_log_measure(self, scales: List[Scale]) -> Optional[float]:
        """
        Rollup: Maximum log10(Measure) across child scales.
        Formula: =MAXIFS(scales!{{LogMeasure}}, scales!{{System}}, {{System}})
        """
        if self._max_log_measure is None:
            self._max_log_measure = max((s._log_measure for s in scales if s.system == self.system), default=0)
        return self._max_log_measure

    def calculate_delta_log_measure(self) -> Optional[float]:
        """
        Calculated: Difference between min and max log measure (numerator for slope).
        Formula: ={{MinLogMeasure}} - {{MaxLogMeasure}}
        """
        if self._delta_log_measure is None:
            self._delta_log_measure = self._min_log_measure - self._max_log_measure
        return self._delta_log_measure

    def calculate_delta_log_scale(self) -> Optional[float]:
        """
        Calculated: Difference between max and min log scale (denominator for slope).
        Formula: ={{MaxLogScale}} - {{MinLogScale}}
        """
        if self._delta_log_scale is None:
            self._delta_log_scale = self._max_log_scale - self._min_log_scale
        return self._delta_log_scale

    def calculate_empirical_log_log_slope(self) -> Optional[float]:
        """
        Calculated: Slope of log-log line from empirical data.
        Formula: ={{DeltaLogMeasure}} / {{DeltaLogScale}}
        """
        if self._empirical_log_log_slope is None:
            self._empirical_log_log_slope = self._delta_log_measure / self._delta_log_scale
        return self._empirical_log_log_slope

    def calculate_slope_error(self) -> Optional[float]:
        """
        Calculated: Difference between empirical and theoretical slopes.
        Formula: ={{EmpiricalLogLogSlope}} - {{TheoreticalLogLogSlope}}
        """
        if self._slope_error is None:
            self._slope_error = self._empirical_log_log_slope - self._theoretical_log_log_slope
        return self._slope_error
